import fs from "fs";
import path from "path";
import { fileURLToPath } from "url";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const ROOT = path.resolve(__dirname, "..", "..");
const SKILLS_ROOT = path.join(ROOT, "skills");

const EXCLUDED_DIRS = new Set(["drafts", ".obsidian"]);
const EXCLUDED_FILES = new Set(["index.md", "README.md", "MIGRATION.md"]);

function parseFrontmatter(text) {
  if (!text.startsWith("---")) return null;
  const end = text.indexOf("\n---", 3);
  if (end === -1) return null;
  const raw = text.slice(4, end).trim();
  const data = {};
  
  for (const line of raw.split(/\r?\n/)) {
    const trimmed = line.trim();
    if (!trimmed || trimmed.startsWith("#") || trimmed.startsWith("- ")) continue;
    const idx = trimmed.indexOf(":");
    if (idx === -1) continue;
    const key = trimmed.slice(0, idx).trim();
    let value = trimmed.slice(idx + 1).trim();
    if ((value.startsWith("\"") && value.endsWith("\"")) || (value.startsWith("'") && value.endsWith("'"))) {
      value = value.slice(1, -1);
    }
    data[key] = value;
  }
  return data;
}

function walkMarkdownFiles(dir, result = []) {
  if (!fs.existsSync(dir)) return result;
  for (const entry of fs.readdirSync(dir, { withFileTypes: true })) {
    if (entry.isDirectory()) {
      if (EXCLUDED_DIRS.has(entry.name)) continue;
      walkMarkdownFiles(path.join(dir, entry.name), result);
    } else if (entry.isFile() && entry.name.endsWith(".md")) {
      if (EXCLUDED_FILES.has(entry.name) && dir === SKILLS_ROOT) continue;
      result.push(path.join(dir, entry.name));
    }
  }
  return result;
}

function generateIndex() {
  const files = walkMarkdownFiles(SKILLS_ROOT);
  const categories = {};

  for (const file of files) {
    const relativePath = path.relative(SKILLS_ROOT, file);
    const parts = relativePath.split(path.sep);
    
    // Determine category
    let category = "Uncategorized";
    if (parts.length > 1) {
      category = parts[0]; // The top-level folder inside skills/ (e.g., 'meta', 'process')
    }

    const content = fs.readFileSync(file, "utf8");
    const fm = parseFrontmatter(content);
    if (!fm || !fm.id) continue; // Skip non-skills

    if (!categories[category]) {
      categories[category] = [];
    }

    // Convert Windows backslashes to posix forward slashes for Markdown links
    const linkPath = relativePath.split(path.sep).join("/");
    
    let title = fm.title || fm.id;
    // Extract title text if it starts with "Category: Title"
    if (title.includes(": ")) {
      title = title.split(": ").slice(1).join(": ");
    }
    
    let statusMarker = "";
    if (fm.status === "deprecated") statusMarker = " *(Deprecated)*";
    if (fm.status === "draft") statusMarker = " *(Draft)*";

    categories[category].push(`- [${fm.id}](./${linkPath}) — ${title}${statusMarker}`);
  }

  // Desired order of categories
  const categoryOrder = ["meta", "process", "architecture", "security", "integrations", "troubleshooting", "libs"];
  
  // Sort missing categories alphabetically and append
  const existingCategories = Object.keys(categories);
  const remainingCategories = existingCategories.filter(c => !categoryOrder.includes(c)).sort();
  const finalOrder = [...categoryOrder, ...remainingCategories];

  let md = `<!-- DO NOT EDIT MANUALLY! -->
<!-- This file is auto-generated by scripts/architecture/generate-skills-index.js -->

# Index: MMB Skills

> Master index of all MMB skills.
> Automatically generated by script (Inverted SSOT).

---

`;

  for (const cat of finalOrder) {
    if (!categories[cat] || categories[cat].length === 0) continue;
    
    // Capitalize category name
    const catName = cat.charAt(0).toUpperCase() + cat.slice(1);
    md += `## ${catName}\n\n`;
    
    if (cat === "meta") {
      md += `_Skills about the skills system itself — templates, lifecycle, anchors, agent behavior._\n_Excluded from audit_skill_coverage._\n\n`;
    }

    categories[cat].sort((a, b) => a.localeCompare(b));
    for (const item of categories[cat]) {
      md += `${item}\n`;
    }
    md += `\n`;
  }

  md += `---

## Service Files

- [README.md](./README.md) — Knowledge base documentation
- [MIGRATION.md](./MIGRATION.md) — Migration status register from MBB (temporary)
`;

  return md;
}

function main() {
  console.log("[docs-index] Generating skills/index.md...");
  const content = generateIndex();
  const outPath = path.join(SKILLS_ROOT, "index.md");
  fs.writeFileSync(outPath, content, "utf8");
  console.log(`[docs-index] Successfully updated ${outPath}`);
}

main();
